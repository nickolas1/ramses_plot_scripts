from __future__ import division

import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.font_manager as fm
import matplotlib.colors as col
import matplotlib.cm as cm
import gc
import sys
import h5py
from astropy import constants as const
from astropy import units as u
from astropy.io import ascii
from os.path import expanduser
from matplotlib import rcParams


"""
usage: python plot_CO_filament_finder_image_turbgrav.py <snap> <axis>
"""


# import ramses helper functions and get figure directory
homedir = expanduser('~')+'/'

# import ramses helper functions and get figure directory
sys.path.append(homedir+'pythonhelpers/ramses/')
from ramses_helpers import *
#mpl.rc_file(homedir+'pythonhelpers/ramses/matplotlibrc')

# set some fonts
fontdir = homedir+'Documents/astronomy/macfontsforpython/'
tfm = fm.FontProperties( # tick font
    fname=fontdir+'Gotham-Book.ttf', size=13)
lfm = fm.FontProperties( # label font main
    fname=fontdir+'Gotham-BookItalic.ttf', size=12) 

rcParams['xtick.direction'] = 'out'

outdir = get_output_path(homedir)
outdir = './'

snapstr = str(int(sys.argv[1])).zfill(5)
infoname = 'reduced_'+snapstr+'/info_'+snapstr+'.txt'
(boxlen, unit_l) = get_boxsize(infoname)

snap = int(sys.argv[1])
axis = int(sys.argv[2])



imshowmap = 'nickmapVD2'
#imshowmap = 'bone_r'

"""
this data is generated by making a surface density map taking into account only
gas that is between 10^3 and 10^4.5 cm^-3. to convert to a crude approximation 
of a C18O map, use
David S. Meier and Jean L. Turner ApJ 551:687 2001 equation 2

N(H2)C18O = 2.42e14 cm^-2 [H2]/[C18O] * exp(5.27/Tex)/(exp(5.27/Tex)-1) IC18O K km/s
[H2]/[C18O] = 2.94e6

so first convert g cm^-2 to cm^-2 using mu = 2.33, then convert to ICO using Tex=10 K
"""
cdmin = 10**-3.3 
cdmax = 10**-1.5
cdmin = 0
cdmax = 4

fileprefix = 'reduced_'+str(snap).zfill(5)+'/'
sinkname = fileprefix+'sink_'+str(snap).zfill(5)+'.csv'


file = fileprefix+'surface_density_C18O'+str(axis)+'.hdf5'

if os.path.exists(file):
    print snap,file
    f = h5py.File(file, 'r')
    sd = f['surface_density_C18O']
    sd = 10**np.array(sd)  # convert to linear units
    print np.mean(sd),np.max(sd)
    sd /= (2.33 * const.m_p.cgs.value) # convert to number density
    print np.mean(sd),np.max(sd)
    sd /= (2.42e14 * 2.94e6) # non-temperature factors of IC18O conversion
    sd /= (np.exp(5.27/10) / (np.exp(5.27/10) - 1)) # temperature part
    print np.mean(sd),np.max(sd)
    fig = plt.figure(figsize = (1.1111111*sd.shape[0]/200, 1.1111111*sd.shape[1]/200), dpi=200)
    ax = fig.add_axes([0.05, 0.05, .9, .9])
    axu = fig.add_axes([0.05, 0.95, .9, .9])
    axl = fig.add_axes([-0.85, 0.05, .9, .9])
    axr = fig.add_axes([0.95, 0.05, 0.9, 0.9])
    axd = fig.add_axes([0.05, -0.85, 0.9, 0.9])
    axul = fig.add_axes([-0.85, 0.95, 0.9, 0.9])
    axur = fig.add_axes([0.95, 0.95, 0.9, 0.9])
    axdl = fig.add_axes([-0.85, -0.85, 0.9, 0.9])
    axdr = fig.add_axes([0.95, -0.85, 0.9, 0.9])
    ax4 = fig.add_axes([0, 0, 1, 1])
    ax.imshow(sd,
          interpolation = 'nearest',
          origin = 'lower',
          vmin = cdmin,
          vmax = cdmax,
          cmap = imshowmap)
    axu.imshow(sd,interpolation = 'nearest',origin = 'lower',vmin = cdmin,vmax = cdmax,cmap = imshowmap)
    axl.imshow(sd,interpolation = 'nearest',origin = 'lower',vmin = cdmin,vmax = cdmax,cmap = imshowmap)
    axr.imshow(sd,interpolation = 'nearest',origin = 'lower',vmin = cdmin,vmax = cdmax,cmap = imshowmap)
    axd.imshow(sd,interpolation = 'nearest',origin = 'lower',vmin = cdmin,vmax = cdmax,cmap = imshowmap)
    axul.imshow(sd,interpolation = 'nearest',origin = 'lower',vmin = cdmin,vmax = cdmax,cmap = imshowmap)
    axur.imshow(sd,interpolation = 'nearest',origin = 'lower',vmin = cdmin,vmax = cdmax,cmap = imshowmap)
    axdl.imshow(sd,interpolation = 'nearest',origin = 'lower',vmin = cdmin,vmax = cdmax,cmap = imshowmap)
    axdr.imshow(sd,interpolation = 'nearest',origin = 'lower',vmin = cdmin,vmax = cdmax,cmap = imshowmap)
    # see if we have any sink particles to plot
    try:
        with open(sinkname): 
            sinks = ascii.read(sinkname, names=sinkcolumnnames, converters=sinkconverters)
            if len(sinks['ID']) > 0: 
                # figure out the size of the sinks in units of 0-1
                #mincell = 1.0/2**lmax
                #sinkrad = 1.5 * mincell
                sscale = sd.shape[0] / boxlen
                
                if axis == 0:
                    i0 = 'y'
                    i1 = 'z'
                if axis == 1:
                    i0 = 'x'
                    i1 = 'z'
                if axis == 2:
                    i0 = 'x'
                    i1 = 'y'

                # convert to imshow scale
                #sinkpos *= res[1] / wd
                #sinkrad *= res[1] / wd

                # color by the log of mass. the minimum that we plot is 0.1 Msun,
                # max is a few hundred.
                mmin = np.log10(1)
                mmax = np.log10(30)
                sinkmap = cm.get_cmap('nickmapSink')
                sinkcolors = sinkmap((np.log10(sinks['mass']) - mmin) / (mmax - mmin))     
                ax.autoscale(False)
                #for s in xrange(len(sinks)):
                #    ax.add_artist(Circle((sinkpos[s,0],sinkpos[s,1]),sinkrad,fc=csink))
                ax.scatter(sinks[i0]*sscale,sinks[i1]*sscale,marker='.',s=20,facecolor=sinkcolors,lw=0.25)              
     
    except IOError:
        pass     
    
    
    # outline the original periodic box
    ax.plot([0, sd.shape[0]-1, sd.shape[0]-1, 0, 0],[0, 0, sd.shape[0]-1, sd.shape[0]-1, 0],
         lw=0.5, ls='--', color = 'c', solid_joinstyle='miter',zorder=300)
    
    ax.set_frame_on(False)
    ax.axes.get_yaxis().set_visible(False)
    ax.axes.get_xaxis().set_visible(False)
    axu.set_frame_on(False)
    axu.axes.get_yaxis().set_visible(False)
    axu.axes.get_xaxis().set_visible(False)
    axl.set_frame_on(False)
    axl.axes.get_yaxis().set_visible(False)
    axl.axes.get_xaxis().set_visible(False)
    axr.set_frame_on(False)
    axr.axes.get_yaxis().set_visible(False)
    axr.axes.get_xaxis().set_visible(False)
    axd.set_frame_on(False)
    axd.axes.get_yaxis().set_visible(False)
    axd.axes.get_xaxis().set_visible(False)
    axul.set_frame_on(False)
    axul.axes.get_yaxis().set_visible(False)
    axul.axes.get_xaxis().set_visible(False)
    axur.set_frame_on(False)
    axur.axes.get_yaxis().set_visible(False)
    axur.axes.get_xaxis().set_visible(False)
    axdl.set_frame_on(False)
    axdl.axes.get_yaxis().set_visible(False)
    axdl.axes.get_xaxis().set_visible(False)
    axdr.set_frame_on(False)
    axdr.axes.get_yaxis().set_visible(False)
    axdr.axes.get_xaxis().set_visible(False)
    
    ax4.set_frame_on(False)
    ax4.axes.get_yaxis().set_visible(False)
    ax4.axes.get_xaxis().set_visible(False)
    ax4.set_xlim(0,1)
    ax4.set_ylim(0,1)
                    
    framesdir = 'finderimage'+str(axis)+'/'
    if not os.path.exists(framesdir):
        os.makedirs(framesdir)

    framename = framesdir+'finderimage'+str(axis)+'_frame_'+str(snap).zfill(5)
    plt.savefig(framename+'_noboxes.png', dpi = 400)
    
    f.close() 
    plt.close() 
    del(f)
    del(sd)
    gc.collect()

